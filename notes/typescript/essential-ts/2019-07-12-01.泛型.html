<!DOCTYPE HTML>
<!--
Prologue by HTML5 UP
html5up.net | @ajlkn
Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
Jekyll integration by Chris Bobbe | chrisbobbe.github.io
-->
<html><head><!-- Robots -->
  <meta name="robots" content="index, follow" /><link rel="canonical" href="make-it-simpler.tech/notes/typescript/essential-ts/2019-07-12-01.%E6%B3%9B%E5%9E%8B.html" /><!-- Title, description, author --><title>01.泛型 | 让IT更简单点 - 一个有信仰的IT爱好者</title>
  <meta name="description" content="Ronnie的个人网站， 旨在提供清晰易懂的编程教学" />
  <meta name="author" content="Ronnie" />
  
  <!-- Open Graph -->
  <meta property="og:title" content="01.泛型 | 让IT更简单点 - 一个有信仰的IT爱好者" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="make-it-simpler.tech/assets/images/avatar.png" />
  <meta property="og:url" content="make-it-simpler.tech/notes/typescript/essential-ts/2019-07-12-01.%E6%B3%9B%E5%9E%8B.html" />
  <meta property="og:site_name" content="让IT更简单点" />
  <meta property="og:description" content="Ronnie的个人网站， 旨在提供清晰易懂的编程教学" />
  
  <!-- Styles -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!--[if lte IE 8]><script src="/assets/js/ie/html5shiv.js" defer></script><![endif]-->
  <link rel="stylesheet" href="/assets/css/main.css" />
  <!--[if lte IE 8]><link rel="stylesheet" href="/assets/css/ie8.css" /><![endif]-->
  <!--[if lte IE 9]><link rel="stylesheet" href="/assets/css/ie9.css" /><![endif]-->
  <!-- <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.1.0/css/all.css" rel="stylesheet"> -->
  <link href="https://cdn.bootcss.com/font-awesome/5.1.0/css/all.css" rel="stylesheet">
  <link rel="stylesheet" href="/assets/css/md-hl-github.css">
  <link rel="stylesheet" href="/assets/css/md-layout-github.css">

  <!-- Scripts -->
  <script src="http://lib.sinaapp.com/js/jquery/1.12.4/jquery-1.12.4.min.js" defer></script>
  <script src="/assets/js/jquery.scrolly.min.js" defer></script>
  <script src="/assets/js/jquery.scrollzer.min.js" defer></script>
  <script src="/assets/js/skel.min.js" defer></script>
  <script src="/assets/js/util.js" defer></script>
  <!--[if lte IE 8]><script src="/assets/js/ie/respond.min.js" defer></script><![endif]-->
  <script src="/assets/js/main.js" defer></script>

</head><body><!-- Header -->
<div id="header">
  <div class="top"><!-- Logo -->
<div id="logo">
  <a href="make-it-simpler.tech/" id="home-link">
    <span class="image avatar48"><img src="/assets/images/avatar.png" alt="Avatar of Ronnie" /></span>
    <h1 id="title">让IT更简单点</h1>
    <p>一个有信仰的IT爱好者</p>
  </a>
</div><!-- Nav -->
<nav id="nav">
  <ul><li><a href="make-it-simpler.tech/" id="主页-link">
            <span class="icon fa-home">主页</span>
          </a></li><li><a href="make-it-simpler.tech/blog.html" id="文章-link">
            <span class="icon fa-link">文章</span>
          </a></li></ul>
</nav></div>
  <div class="bottom"><!-- Social Icons -->
<ul class="icons"><li><a href="https://github.com/scjmjy" class="icon-b fa-github"><span class="label">GitHub</span></a></li><li><a href="mailto:mjyok12345@gmail.com" class="icon fa-envelope"><span class="label">Email</span></a></li></ul>
</div>
</div>
<!-- Main -->
<div id="main">
	<!-- Post -->
	<article class="markdown-body">
	  <div class="container">
			<header>
				<h2>01.泛型</h2>
				<p>Ronnie, 12 July 2019</p>
			</header><!-- # 泛型（Generic Types） -->
<p>本节讲解TypeScript中的基本泛型（Generic Types）特性。</p>

<p>本节目录：
<!-- TOC --></p>

<ul>
  <li><a href="#1-基本语法">1. 基本语法</a>
    <ul>
      <li><a href="#11-示例">1.1. 示例</a></li>
    </ul>
  </li>
  <li><a href="#2-使用泛型">2. 使用泛型</a>
    <ul>
      <li><a href="#21-示例">2.1. 示例</a></li>
    </ul>
  </li>
  <li><a href="#3-约束泛型的类型">3. 约束泛型的类型</a>
    <ul>
      <li><a href="#31-语法示例">3.1. 语法示例</a></li>
      <li><a href="#32-使用其他种类的类型来约束泛型">3.2. 使用其他种类的类型来约束泛型</a></li>
    </ul>
  </li>
  <li><a href="#4-定义多个泛型形参">4. 定义多个泛型形参</a>
    <ul>
      <li><a href="#41-示例">4.1. 示例</a></li>
    </ul>
  </li>
  <li><a href="#5-给函数和方法使用泛型参数">5. 给函数和方法使用泛型参数</a></li>
  <li><a href="#6-允许编译器推断泛型实参">6. 允许编译器推断泛型实参</a>
    <ul>
      <li><a href="#61-示例">6.1. 示例</a></li>
    </ul>
  </li>
  <li><a href="#7-继承泛型">7. 继承泛型</a>
    <ul>
      <li><a href="#71-不改变形参只给现有的泛型类添加额外的功能">7.1. 不改变形参，只给现有的泛型类添加额外的功能</a>
        <ul>
          <li><a href="#711-示例">7.1.1. 示例</a></li>
        </ul>
      </li>
      <li><a href="#72-固定泛型参数">7.2. 固定泛型参数</a>
        <ul>
          <li><a href="#721-示例">7.2.1. 示例</a></li>
        </ul>
      </li>
      <li><a href="#73-限制泛型参数">7.3. 限制泛型参数</a>
        <ul>
          <li><a href="#731-示例">7.3.1. 示例</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#8-泛型的类型守护">8. 泛型的类型守护</a>
    <ul>
      <li><a href="#81-对于有限种类的泛型参数">8.1. 对于有限种类的泛型参数</a></li>
      <li><a href="#82-对于任意类型的泛型参数">8.2. 对于任意类型的泛型参数</a></li>
    </ul>
  </li>
  <li><a href="#9-泛型类的静态属性或方法">9. 泛型类的静态属性或方法</a></li>
  <li><a href="#10-泛型接口">10. 泛型接口</a>
    <ul>
      <li><a href="#101-语法示例">10.1. 语法示例</a></li>
      <li><a href="#102-继承泛型接口">10.2. 继承泛型接口</a></li>
      <li><a href="#103-实现泛型接口">10.3. 实现泛型接口</a></li>
    </ul>
  </li>
</ul>

<!-- /TOC -->

<hr />

<h2 id="1-基本语法">1. 基本语法</h2>
<ul>
  <li>在类名后面添加一对尖括号”&lt;&gt;”，并在”&lt;&gt;”之间添加<strong>泛型参数</strong>（Genric Type Parameter），例如：<code class="language-plaintext highlighter-rouge">class DataCollection&lt;T&gt;</code></li>
  <li>在类中使用到该泛型的地方都用<strong>T</strong>代替</li>
  <li>使用泛型的类被成为<strong>泛型类</strong>（generic class）</li>
</ul>

<h3 id="11-示例">1.1. 示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// &lt;T&gt; 称为泛型参数（Parameter）</span>
    <span class="kr">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="na">initialItems</span><span class="p">:</span> <span class="nx">T</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">initialItems</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">add</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">get</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">personCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">([</span><span class="k">new</span> <span class="nx">Person</span><span class="p">]);</span> <span class="c1">// &lt;Person&gt; 称为泛型实参（Argument）</span>
</code></pre></div></div>

<p><img src="/assets/images/TypeScript学习笔记/Essential-TypeScript/generic_type.png" alt="generic_type" /></p>

<h2 id="2-使用泛型">2. 使用泛型</h2>
<ul>
  <li>当示例化一个具体的泛型类时，用具体的泛型实参（Generic Type Argument）来替换泛型形参（Generic Type Parameter）</li>
</ul>

<h3 id="21-示例">2.1. 示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">personCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">([</span><span class="k">new</span> <span class="nx">Person</span><span class="p">]);</span> <span class="c1">// Person是泛型实参</span>
</code></pre></div></div>

<p><img src="/assets/images/TypeScript学习笔记/Essential-TypeScript/generic_type_argument.png" alt="generic_type_argument" /></p>

<h2 id="3-约束泛型的类型">3. 约束泛型的类型</h2>
<ul>
  <li>默认情况下，泛型形参 <strong>T</strong> 是 <code class="language-plaintext highlighter-rouge">any</code> 类型的，所以类中不能使用任何 <strong>T</strong> 的属性或方法</li>
  <li>可以通过 <code class="language-plaintext highlighter-rouge">extends</code> 来约束泛型类型为特定的类型</li>
</ul>

<h3 id="31-语法示例">3.1. 语法示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="o">|</span> <span class="nx">Product</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T的类型只能是Person或者Product或者Person|Product及其子类</span>
    <span class="kr">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="na">initialItems</span><span class="p">:</span> <span class="nx">T</span><span class="p">[])</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">initialItems</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">add</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">get</span><span class="p">(</span><span class="na">index</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">[</span><span class="nx">index</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="/assets/images/TypeScript学习笔记/Essential-TypeScript/generic_type_restriction.png" alt="generic_type_restriction" /></p>

<h3 id="32-使用其他种类的类型来约束泛型">3.2. 使用其他种类的类型来约束泛型</h3>
<ul>
  <li>
    <p>使用形状类型</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="nx">string</span> <span class="p">}</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 只允许匹配{ name: string }的类型</span>
      <span class="c1">// ...</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>还可以使用类型别名</li>
  <li>还可以使用接口</li>
</ul>

<h2 id="4-定义多个泛型形参">4. 定义多个泛型形参</h2>
<ul>
  <li>泛型支持同时定义多个形参</li>
</ul>

<h3 id="41-示例">4.1. 示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="nx">string</span> <span class="p">},</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T,U都是泛型形参</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">personCollection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="p">,</span> <span class="nx">Product</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// Person，Product分别是T，U的实参</span>
</code></pre></div></div>

<h2 id="5-给函数和方法使用泛型参数">5. 给函数和方法使用泛型参数</h2>
<ul>
  <li>
    <p>函数</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">printName</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="nx">printName</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">SH</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>方法</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">Data</span> <span class="p">{</span>
      <span class="nx">printName</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Data</span><span class="p">();</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">printName</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">SH</span><span class="dl">'</span><span class="p">));</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="6-允许编译器推断泛型实参">6. 允许编译器推断泛型实参</h2>
<ul>
  <li>在使用泛型的时候，可以不用显示地给出实参，此时tsc会自动推断实参的类型</li>
</ul>

<h3 id="61-示例">6.1. 示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">Person</span><span class="p">,</span> <span class="nx">Product</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./dataTypes</span><span class="dl">'</span>

<span class="kd">class</span> <span class="nx">DataIntersectedCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">U</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="na">items</span><span class="p">:</span> <span class="p">(</span><span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span><span class="p">)[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="na">initialItem1</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">initialItem2</span><span class="p">:</span> <span class="nx">U</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">intersectAndCollect</span><span class="p">(</span><span class="nx">initialItem1</span><span class="p">,</span> <span class="nx">initialItem2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">intersectAndCollect</span><span class="p">(</span><span class="na">item1</span><span class="p">:</span> <span class="nx">T</span><span class="p">,</span> <span class="na">item2</span><span class="p">:</span> <span class="nx">U</span><span class="p">):</span> <span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="na">result</span><span class="p">:</span> <span class="nx">T</span> <span class="o">&amp;</span> <span class="nx">U</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span><span class="nx">item1</span><span class="p">,</span> <span class="p">...</span><span class="nx">item2</span> <span class="p">};</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">person</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">SH</span><span class="dl">'</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">product</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Product</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hat</span><span class="dl">'</span><span class="p">,</span> <span class="mi">55</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataIntersectedCollection</span><span class="p">(</span><span class="nx">person</span><span class="p">,</span> <span class="nx">product</span><span class="p">);</span> <span class="c1">// DataIntersectedCollection被推断为DataIntersectedCollection&lt;Person,Product&gt;类型</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">items</span><span class="p">);</span> <span class="c1">// 输出：[ { name: 'Hat', city: 'SH', price: 55 } ]</span>
</code></pre></div></div>

<h2 id="7-继承泛型">7. 继承泛型</h2>
<ul>
  <li>泛型可以被继承，子类的形参必须兼容父类的形参</li>
  <li>子类可以使用以下几种不同的方式来处理泛型参数</li>
</ul>

<h3 id="71-不改变形参只给现有的泛型类添加额外的功能">7.1. 不改变形参，只给现有的泛型类添加额外的功能</h3>
<ul>
  <li>使用与父类相同的形参</li>
  <li>在子类中添加额外的属性或方法</li>
</ul>

<h4 id="711-示例">7.1.1. 示例</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">DataCollectionPlus</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 第二个T和第一个T是一样的，即只允许Person及其子类</span>
    <span class="nx">advancedProp</span><span class="p">;</span>
    <span class="nx">advancedMethod</span><span class="p">(){}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="72-固定泛型参数">7.2. 固定泛型参数</h3>
<ul>
  <li>子类可以给泛型父类具体的泛型实参来固定泛型</li>
</ul>

<h4 id="721-示例">7.2.1. 示例</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">PersonCollection</span> <span class="kd">extends</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 使用Person固定</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="73-限制泛型参数">7.3. 限制泛型参数</h3>
<ul>
  <li>子类的泛型参数可以添加比父类更严格的限制</li>
</ul>

<h4 id="731-示例">7.3.1. 示例</h4>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T可以是任意类型</span>
<span class="p">}</span>
<span class="kd">class</span> <span class="nx">PersonCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T只能是Person及其子类类型</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="8-泛型的类型守护">8. 泛型的类型守护</h2>

<h3 id="81-对于有限种类的泛型参数">8.1. 对于有限种类的泛型参数</h3>
<ul>
  <li>
    <p>使用instanceof判断类型</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span> <span class="o">|</span> <span class="nx">Product</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T并不是任意类型，受限于Person和Product</span>
      <span class="kr">public</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="nx">collect</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">filterPerson</span><span class="p">():</span> <span class="nx">T</span><span class="p">[]</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">);</span> <span class="c1">// instanceof</span>
      <span class="p">}</span>
      <span class="nx">filterProduct</span><span class="p">():</span> <span class="nx">T</span><span class="p">[]</span> <span class="p">{</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="k">instanceof</span> <span class="nx">Product</span><span class="p">);</span> <span class="c1">// instanceof</span>
      <span class="p">}</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span> <span class="o">|</span> <span class="nx">Product</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">collect</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">SH</span><span class="dl">'</span><span class="p">));</span>
  <span class="nx">data</span><span class="p">.</span><span class="nx">collect</span><span class="p">(</span><span class="k">new</span> <span class="nx">Product</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hat</span><span class="dl">'</span><span class="p">,</span> <span class="mi">55</span><span class="p">));</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">filterPerson</span><span class="p">());</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">filterProduct</span><span class="p">());</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="82-对于任意类型的泛型参数">8.2. 对于任意类型的泛型参数</h3>
<ul>
  <li>在上述的例子中，如果不仅仅只有Person和Product类型，那么每个类型都需要一个 <strong>filter*</strong> 方法，这明显不切实际</li>
  <li>
    <p>我们希望利用泛型的特性来一次性实现类型判断</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// T可以是任意类型</span>
      <span class="kr">public</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
      <span class="nx">collect</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">filter</span><span class="o">&lt;</span><span class="nx">V</span> <span class="kd">extends</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">():</span> <span class="nx">V</span><span class="p">[]</span> <span class="p">{</span> <span class="c1">// 通过泛型方法和instanceof来实现类型保护</span>
          <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span> <span class="k">instanceof</span> <span class="nx">V</span><span class="p">)</span> <span class="k">as</span> <span class="nx">V</span><span class="p">[];</span> <span class="c1">// 然而，Error：'V' only refers to a type, but is being used as a value here.ts(2693)</span>
      <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>然而，上面的代码会报错：’V’ only refers to a type, but is being used as a value here.ts(2693)
    <ul>
      <li>因为泛型是TypeScript在编译阶段的特性，并没有对应的JavaScript的实现，所以无法通过 <code class="language-plaintext highlighter-rouge">instanceof V</code> 来实现上面的目的</li>
      <li>
        <p>解决方法是配合使用<strong>谓词函数（predicate function）</strong></p>

        <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kr">public</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="nx">collect</span><span class="p">(</span><span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">filter</span><span class="o">&lt;</span><span class="nx">V</span> <span class="kd">extends</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="na">predicate</span><span class="p">:</span> <span class="p">(</span><span class="nx">testObj</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">testObj</span> <span class="nx">is</span> <span class="nx">V</span><span class="p">):</span> <span class="nx">V</span><span class="p">[]</span> <span class="p">{</span> <span class="c1">// 使用谓词函数作为参数，用来判断类型</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">predicate</span><span class="p">(</span><span class="nx">item</span><span class="p">))</span> <span class="k">as</span> <span class="nx">V</span><span class="p">[];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">Person</span> <span class="o">|</span> <span class="nx">Product</span><span class="o">&gt;</span><span class="p">();</span>
<span class="nx">data</span><span class="p">.</span><span class="nx">collect</span><span class="p">(</span><span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">John</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">SH</span><span class="dl">'</span><span class="p">));</span>
<span class="nx">data</span><span class="p">.</span><span class="nx">collect</span><span class="p">(</span><span class="k">new</span> <span class="nx">Product</span><span class="p">(</span><span class="dl">'</span><span class="s1">Hat</span><span class="dl">'</span><span class="p">,</span> <span class="mi">55</span><span class="p">));</span>

<span class="kd">function</span> <span class="nx">isProduct</span><span class="p">(</span><span class="nx">testObj</span><span class="p">):</span> <span class="nx">testObj</span> <span class="nx">is</span> <span class="nx">Product</span> <span class="p">{</span> <span class="c1">// Product的谓词函数</span>
    <span class="k">return</span> <span class="nx">testObj</span> <span class="k">instanceof</span> <span class="nx">Product</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">isPerson</span><span class="p">(</span><span class="nx">testObj</span><span class="p">):</span> <span class="nx">testObj</span> <span class="nx">is</span> <span class="nx">Person</span> <span class="p">{</span> <span class="c1">// Person的谓词函数</span>
    <span class="k">return</span> <span class="nx">testObj</span> <span class="k">instanceof</span> <span class="nx">Person</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">products</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="o">&lt;</span><span class="nx">Product</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">isProduct</span><span class="p">);</span> <span class="c1">// Ok,products的类型是Product[]</span>
<span class="kd">let</span> <span class="nx">persons</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">filter</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">isPerson</span><span class="p">);</span> <span class="c1">// Ok,persons的类型是Person[]</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<h2 id="9-泛型类的静态属性或方法">9. 泛型类的静态属性或方法</h2>
<ul>
  <li>
    <p>泛型类也可以定义静态属性或方法，访问的时候不需要附带泛型实参，直接像普通类访问它们的静态元素一样</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="kd">static</span> <span class="na">description</span><span class="p">:</span><span class="nx">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">Collecting everything!</span><span class="dl">'</span><span class="p">;</span>
      <span class="kd">static</span> <span class="nx">reverse</span><span class="p">(</span><span class="na">items</span><span class="p">:</span> <span class="nx">any</span><span class="p">[])</span> <span class="p">{</span> <span class="c1">// 定义静态方法</span>
          <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span> <span class="c1">// 定义静态属性</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">DataCollection</span><span class="p">.</span><span class="nx">description</span><span class="p">);</span> <span class="c1">// 使用静态属性</span>
  <span class="kd">let</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">DataCollection</span><span class="p">.</span><span class="nx">reverse</span><span class="p">(</span><span class="nx">items</span><span class="p">));</span> <span class="c1">// 使用静态方法</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>静态方法也可以是泛型的，静态属性不支持泛型</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">DataCollection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
      <span class="kd">static</span> <span class="nx">reverse</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="nx">T</span><span class="p">[]</span> <span class="p">{</span> <span class="c1">// 定义带有类型参数的静态方法</span>
          <span class="k">return</span> <span class="nx">items</span><span class="p">.</span><span class="nx">reverse</span><span class="p">();</span>
      <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">DataCollection</span><span class="p">.</span><span class="nx">reverse</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">items</span><span class="p">));</span> <span class="c1">// 使用带有类型参数的静态方法</span>
</code></pre></div>    </div>
  </li>
</ul>

<h2 id="10-泛型接口">10. 泛型接口</h2>
<ul>
  <li>和类一样，接口也可以被定义成泛型的</li>
  <li>泛型接口的语法也和泛型类一致</li>
</ul>

<h3 id="101-语法示例">10.1. 语法示例</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">type</span> <span class="nx">shapeType</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="nx">string</span> <span class="p">};</span>
<span class="kr">interface</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">shapeType</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="na">count</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
    <span class="nx">add</span><span class="p">(...</span><span class="na">newItems</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="k">void</span><span class="p">;</span>
    <span class="kd">get</span><span class="p">(</span><span class="na">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="102-继承泛型接口">10.2. 继承泛型接口</h3>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">SearchableCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">shapeType</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 保持和父接口一样的类型参数</span>
    <span class="nx">find</span><span class="p">(</span><span class="na">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">ProductCollection</span> <span class="kd">extends</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">Product</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 固定父接口的类型参数为Product</span>
    <span class="nx">sumPrices</span><span class="p">():</span> <span class="nx">number</span><span class="p">;</span>
<span class="p">}</span>
<span class="kr">interface</span> <span class="nx">PeopleCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Person</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 更加限制类型参数为Person及其子类</span>
    <span class="nx">getNames</span><span class="p">():</span> <span class="nx">string</span><span class="p">[];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="103-实现泛型接口">10.3. 实现泛型接口</h3>
<ol>
  <li>
    <p>传递泛型类型参数</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">class</span> <span class="nx">ArrayCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">shapeType</span><span class="o">&gt;</span> <span class="kr">implements</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 传递T类型给父接口</span>
     <span class="kr">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
     <span class="nx">add</span><span class="p">(...</span><span class="na">newItems</span><span class="p">:</span> <span class="nx">any</span><span class="p">[]):</span> <span class="k">void</span> <span class="p">{</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">newItems</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kd">get</span><span class="p">(</span><span class="na">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">name</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kd">get</span> <span class="nx">count</span><span class="p">():</span> <span class="nx">number</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="kd">let</span> <span class="na">peopleCollection</span><span class="p">:</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ArrayCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// tsc知道Collection&lt;Person&gt;适配ArrayCollection&lt;Person&gt;</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>限制或固定泛型类型参数</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kd">class</span> <span class="nx">PersonCollection</span> <span class="kr">implements</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// 限制或固定泛型类型参数为Person</span>
     <span class="kr">private</span> <span class="na">items</span><span class="p">:</span> <span class="nx">Person</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
     <span class="nx">add</span><span class="p">(...</span><span class="na">newItems</span><span class="p">:</span> <span class="nx">Person</span><span class="p">[]):</span> <span class="k">void</span> <span class="p">{</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">newItems</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kd">get</span><span class="p">(</span><span class="na">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">Person</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">name</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kd">get</span> <span class="nx">count</span><span class="p">():</span> <span class="nx">number</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="kd">let</span> <span class="na">peopleCollection</span><span class="p">:</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">PersonCollection</span><span class="p">();</span> <span class="c1">// tsc知道Collection&lt;Person&gt;适配PersonCollection</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>泛型接口的抽象实现</p>

    <div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">abstract</span> <span class="kd">class</span> <span class="nx">ArrayCollection</span><span class="o">&lt;</span><span class="nx">T</span> <span class="kd">extends</span> <span class="nx">shapeType</span><span class="o">&gt;</span> <span class="kr">implements</span> <span class="nx">Collection</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">//抽象实现，实现部分属性和方法</span>
     <span class="kr">protected</span> <span class="na">items</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
     <span class="nx">add</span><span class="p">(...</span><span class="na">newItems</span><span class="p">:</span> <span class="nx">T</span><span class="p">[]):</span> <span class="k">void</span> <span class="p">{</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">newItems</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="kd">get</span> <span class="nx">count</span><span class="p">():</span> <span class="nx">number</span> <span class="p">{</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="nx">abstract</span> <span class="kd">get</span><span class="p">(</span><span class="na">searchTerm</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">T</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 把get方法留给子类来实现</span>
 <span class="p">}</span>
 <span class="kd">class</span> <span class="nx">ProductCollection</span> <span class="kd">extends</span> <span class="nx">ArrayCollection</span><span class="o">&lt;</span><span class="nx">Product</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="kd">get</span><span class="p">(</span><span class="na">searchTerm</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">Product</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>  <span class="c1">// 子类实现get方法</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">name</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
 <span class="kd">class</span> <span class="nx">PersonCollection</span> <span class="kd">extends</span> <span class="nx">ArrayCollection</span><span class="o">&lt;</span><span class="nx">Person</span><span class="o">&gt;</span> <span class="p">{</span>
     <span class="kd">get</span><span class="p">(</span><span class="na">searchTerm</span><span class="p">:</span> <span class="nx">string</span><span class="p">):</span> <span class="nx">Person</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>  <span class="c1">// 子类实现get方法</span>
         <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">item</span> <span class="o">=&gt;</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="nx">name</span> <span class="o">||</span> <span class="nx">item</span><span class="p">.</span><span class="nx">city</span> <span class="o">===</span> <span class="nx">name</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<hr />

<p>接下来我们学习泛型的高级用法——<a href="/notes/typescript/essential-ts/2019-07-13-02.%E9%AB%98%E7%BA%A7%E6%B3%9B%E5%9E%8B.html">高级泛型</a>。</p>
</div>
	</article>
</div><!-- Footer -->
<div id="footer" style="margin-bottom: 0;">
  
  <!-- Copyright -->
  <ul class="copyright">
    
      <li>&copy;让IT更简单点. All rights reserved.</li>
    
    <li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
    <li>Jekyll integration: <a href="https://chrisbobbe.github.io/">Chris Bobbe</a></li>
  </ul>
  
</div></body>
</html>