# 函数返回值

- [1.1. 返回值类型推断](#11-返回值类型推断)
- [1.2. 禁止隐式返回](#12-禁止隐式返回)
  - [1.2.1. 示例](#121-示例)
- [1.3. 空返回值函数（Void Functions）](#13-空返回值函数void-functions)
  - [1.3.1. 示例](#131-示例)
- [1.4. 重载函数类型](#14-重载函数类型)
  - [1.4.1. 语法](#141-语法)
  - [1.4.2. 示例](#142-示例)

## 1.1. 返回值类型推断
- 如果没有显示的注释函数的返回值类型，tsc会推断返回值的类型，如果有多个可能的类型，则会使用联合类型。

## 1.2. 禁止隐式返回
- tsc提供 **"noImplicitReturns": true** 来禁止隐式返回
### 1.2.1. 示例
```typescript
// "noImplicitReturns": true
function divide(dividend:number,divisor:number) {
    if (divisor && divisor!==0) {
        return dividend/divisor;
    }
    // 这一行应该显示的返回，否则会报错：Not all code paths return a value.ts(7030)
}
```

## 1.3. 空返回值函数（Void Functions）
- 语法：使用**void**类型注释
### 1.3.1. 示例
```typescript
function greeting(): void {
    console.log('Hello there!');
}
```

## 1.4. 重载函数类型
- 函数参数的联合类型和返回值的联合类型没有一一对应的关系，考虑以下例子
    ```typescript
    // "strictNullChecks": true
    function calculateTax(amount:number|null): number|null {
        if (amount === null) {
            return null;
        } else {
            return amount*1.2;
        }
    }

    let tax = calculateTax(100); // tax是number|null联合类型
    if (tax !== null) { // 需要额外的判断
        console.log('Tax value: ', tax);
    }
    ```
- 使用函数类型重载可以解决以上的问题
### 1.4.1. 语法
![overriding_function_type](assets/overriding_function_type.png)
### 1.4.2. 示例
```typescript
// "strictNullChecks": true

function calculateTax(amount:number): number; // amount:number对应return number
function calculateTax(amount:null): null;     // amount:null 对应return null
function calculateTax(amount:number|null): number|null {
    if (amount === null) {
        return null;
    } else {
        return amount*1.2;
    }
}

let tax = calculateTax(100); // tax是number类型
// if (tax !== null) { // 不需要额外的判断
    console.log('Tax value: ', tax);
// }
```