# 类型保护（Type Guard）

- [1.1. 简介](#11-简介)
- [1.2. 基本语法](#12-基本语法)
  - [1.2.1. 示例1](#121-示例1)
  - [1.2.2. 示例2](#122-示例2)
- [1.3. never类型](#13-never类型)
  - [1.3.1. 示例](#131-示例)


## 1.1. 简介
- 在不使用类型断言的情况下，可以使用**typeof**来测试JavaScript基本类型
- 对于object类型，使用**instanceof**，这将在以后的章节里讲解
## 1.2. 基本语法
- 使用 **typeof** 关键词，例如 **if (typeof add1 === 'number') {...}**
- 在编译阶段，tsc会自动识别类型保护

### 1.2.1. 示例1
```typescript
function add(add1:number, add2:number): number|string {
    return add1 + add2;
}
let add1 = 10.555;
let add2 = 20;
let sum = add(add1, add2);
if (typeof sum === 'number') {
    console.log(sum.toFixed(2)); // tsc识别类型保护，确认sum是number类型，所以可以使用Number.toFixed方法
}
```
### 1.2.2. 示例2
```typescript
function add(add1:number, add2:number): number|string {
    return add1 + add2;
}
let add1 = 10.555;
let add2 = 20;
let sum = add(add1, add2);
switch (typeof sum) {
  case 'number':
    console.log(sum.toFixed(2)); // tsc识别类型保护，确认sum是number类型，所以可以使用Number.toFixed方法
    break;
  case 'string':
    console.log(sum.charAt(0)); // tsc识别类型保护，确认sum是string类型，所以可以使用String.charAt方法
    break;
}
```

## 1.3. never类型
- 在上述[示例2](#122-示例2)中，当类型保护的所有可能的类型都被处理之后，**sum**就会被tsc确定为never类型
- never类型的变量不能使用任何属性或方法，只能被赋值给另一个never类型的变量
### 1.3.1. 示例
```typescript
function add(add1: number, add2: number): number | string {
    return add1 + add2;
}
let add1 = 10.555;
let add2 = 20;
let sum = add(add1, add2);
switch (typeof sum) {
    case 'number':
        console.log(sum.toFixed(2)); // tsc识别类型保护，确认sum是number类型，所以可以使用Number.toFixed方法
        break;
    case 'string':
        console.log(sum.charAt(0)); // tsc识别类型保护，确认sum是string类型，所以可以使用String.charAt方法
        break;
    default: // Unexpected
        console.log(sum.toString());// Error：Property 'toString' does not exist on type 'never'.ts(2339)
        let val:never = sum; // Ok
}
```