# Nullable类型

- [1.1. 简介](#11-简介)
- [1.2. 空值导致的问题](#12-空值导致的问题)
  - [1.2.1. 示例](#121-示例)
- [1.3. 限制Nullable赋值](#13-限制nullable赋值)
  - [1.3.1. 示例: tsconfig.json](#131-示例-tsconfigjson)
  - [1.3.2. 效果](#132-效果)
  - [1.3.3. 从联合类型中移除null](#133-从联合类型中移除null)
    - [1.3.3.1. 非空断言（non-null assertion）移除联合类型中的null](#1331-非空断言non-null-assertion移除联合类型中的null)
      - [1.3.3.1.1. 示例](#13311-示例)
    - [1.3.3.2. 类型守卫移除联合类型中的null](#1332-类型守卫移除联合类型中的null)
      - [1.3.3.2.1. 示例](#13321-示例)
- [1.4. 明确赋值断言（Definite Assignment Assertion）](#14-明确赋值断言definite-assignment-assertion)
  - [1.4.1. 示例](#141-示例)


## 1.1. 简介
- JavaScript基本类型中有**null**和**undefined**类型
  - **null** 类型只能被赋值为**null**值，用来表达不存在或不合法的东西 
  - **undefined**类型只能被赋值为**undefined**值，在一个变量被声明但是没有定义的时候使用
- 问题是，在默认情况下，TypeScript将**null**和**undefined**视为所有类型的合法值。

## 1.2. 空值导致的问题
- 默认情况下，空值确实会导致类型检查中的不一致性

### 1.2.1. 示例
```typescript
function add(add1: number, add2: number): number | string {
  if (1) {
    return null;
  }
  return add1 + add2;
}
let add1 = 10.555;
let add2 = 20;
let sum: number|string = add(add1, add2); // sum不是number也不是string，而是null
switch (typeof sum) {
    case 'number':
        console.log(sum.toFixed(2)); 
        break;
    case 'string':
        console.log(sum.charAt(0));
        break;
    default:
        console.log(`Unexpected type for value: ${sum}`); // sum是null
}
```
运行结果输出为：**Unexpected type for value: null**

## 1.3. 限制Nullable赋值
- 为了避免以上示例的问题，tsc提供了**strictNullChecks**编译器选项来限制空值的赋值
### 1.3.1. 示例: tsconfig.json
```json
{
    "compilerOptions": {
        ...省略其他选项
        "strictNullChecks": true
    }
}
```
### 1.3.2. 效果
```typescript
function add(add1: number, add2: number): number | string | null {
    return add1 + add2;
}

let sum1: number | string = add(1, 2); // Error: Type 'string | number | null' is not assignable to type 'string | number'.  Type 'null' is not assignable to type 'string | number'.ts(2322)
```
### 1.3.3. 从联合类型中移除null
- **strictNullChecks**功能打开的情况下，如果联合类型中有null，那么就无法使用任何属性或方法，这个联合类型的值就直接无法使用了
- 有两种方法可以解决
  1. 非空断言
  2. 类型守卫（更安全的方式）
#### 1.3.3.1. 非空断言（non-null assertion）移除联合类型中的null
- 非空断言告诉tsc一个值的类型不是null类型，这就把null从联合类型中去除了
- 非空断言应该在你确定null值不会出现的情况下使用
- 语法：在值后面添加“!”
  ![non-null assertion](assets/non-null_assertion.png)
##### 1.3.3.1.1. 示例
```typescript
// "strictNullChecks": true
function add(add1:number, add2:number): number|string|null {
  return add1 + add2;
}
let sum:number|string = add(1,2); // Error
let sum:number|string = add(1,2)!; // Ok："!"表示非空断言
```
#### 1.3.3.2. 类型守卫移除联合类型中的null
##### 1.3.3.2.1. 示例
```typescript
// "strictNullChecks": true
function add(add1: number, add2: number): number | string | null {
    return add1 + add2;
}

let sum1: number | string | null = add(1, 2);
let sum2: number | string = sum1; // Error
if (sum1 !== null) {
    let sum3: number | string = sum1; // Ok：tsc识别“if (sum1 !== null)”类型守卫，知道sum1不可能是null
}
```
## 1.4. 明确赋值断言（Definite Assignment Assertion）
- **strictNullChecks**功能打开的情况下，一个值在它被赋值之前使用的话，tsc就会报错。这是一个有用的功能。但是某些情况下，可能需要在赋值之前使用一个值。明确赋值断言（Definite Assignment Assertion）可以解决这个问题。
- 语法：在变量名称后面添加“!”，例如：**let value!: string | number | null;**

### 1.4.1. 示例
```typescript
let value1: number | null;
eval('value1 = 10'); // value1的值会被赋值为10，所以下面一句代码是没有问题的，但是tsc会报错
let value2 = value1; // Error：Variable 'value1' is used before being assigned.ts(2454)

let value3!: number | null; //Definite Assignment Assertion
eval('value3 = 10'); 
let value4 = value3; // Ok
```